<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Chocolate Animation</title>
  <!-- GSAP & Three.js libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Tangerine:wght@700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #1a1a1a;
    }
    #canvas-container {
      position: fixed;
      width: 100vw;
      height: 100vh;
      top: 0;
      left: 0;
    }
    /* Message area below the chocolate bar */
    .message {
      position: absolute;
      bottom: 50px;
      width: 100%;
      text-align: center;
      font-family: 'Tangerine', cursive;
      font-size: 2rem;
      color: #9A031E;
      opacity: 0;
      pointer-events: none;
    }
    .particle,
    .wrapper-particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
    }
    .particle {
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, #3D1C02 0%, transparent 70%);
    }
    .wrapper-particle {
      width: 12px;
      height: 12px;
      background: radial-gradient(circle, #FFD700 0%, transparent 70%);
    }
    .heart {
      position: absolute;
      width: 30px;
      height: 30px;
      /* Create a red-to-pink gradient heart with a soft glow */
      background: radial-gradient(circle, rgba(154,3,30,1) 0%, rgba(255,111,97,1) 100%);
      clip-path: polygon(50% 0%, 61% 10%, 75% 15%, 85% 30%, 90% 45%, 85% 60%, 75% 75%, 50% 100%, 25% 75%, 15% 60%, 10% 45%, 15% 30%, 25% 15%, 39% 10%);
      filter: drop-shadow(0 0 8px rgba(255,111,97,1));
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="message"></div>
  <script>
    /*****************************
     * Global Variables & Setup *
     *****************************/
    let isWrapperOpened = false;
    let currentBiteGroup = null;  // Tracks the currently bitten piece (if any)
    let biteTimeout = null;

    // THREE.JS SETUP
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting for realistic shadows and reflections
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);
    camera.position.z = 7;

    /************************************
     * Materials & Textures (WebGL)     *
     ************************************/
    // Chocolate Material: Rich dark brown (#3D1C02) with subtle highlights.
    const chocolateColor = new THREE.Color("#3D1C02");
    const chocolateTexture = new THREE.DataTexture(new Uint8Array([
      Math.floor(chocolateColor.r * 255),
      Math.floor(chocolateColor.g * 255),
      Math.floor(chocolateColor.b * 255),
      255
    ]), 1, 1, THREE.RGBAFormat);
    chocolateTexture.needsUpdate = true;
    const chocolateMaterial = new THREE.MeshPhysicalMaterial({
      map: chocolateTexture,
      roughness: 0.7,
      metalness: 0,
      clearcoat: 0.3,
      clearcoatRoughness: 0.25
    });

    // Wrapper Material: Gold foil (#FFD700) with metallic reflections.
    const wrapperColor = new THREE.Color("#FFD700");
    const wrapperTexture = new THREE.DataTexture(new Uint8Array([
      Math.floor(wrapperColor.r * 255),
      Math.floor(wrapperColor.g * 255),
      Math.floor(wrapperColor.b * 255),
      255
    ]), 1, 1, THREE.RGBAFormat);
    wrapperTexture.needsUpdate = true;
    const wrapperMaterial = new THREE.MeshPhysicalMaterial({
      map: wrapperTexture,
      roughness: 0.2,
      metalness: 0.8,
      side: THREE.DoubleSide
    });

    /**********************************
     * Chocolate Bar & Segments Group *
     **********************************/
    const chocolateBar = new THREE.Group();
    scene.add(chocolateBar);

    // Create 6 chocolate segments arranged in 2 rows x 3 columns.
    const segments = [];
    const segmentRows = 2, segmentCols = 3;
    const segmentWidth = 1.2, segmentHeight = 0.9, segmentDepth = 0.4;
    const spacingX = 0.1, spacingY = 0.1;
    for (let row = 0; row < segmentRows; row++){
      for (let col = 0; col < segmentCols; col++){
        const segGeom = new THREE.BoxGeometry(segmentWidth, segmentHeight, segmentDepth);
        const segMesh = new THREE.Mesh(segGeom, chocolateMaterial.clone());
        // Center the grid on the scene.
        segMesh.position.x = (col - (segmentCols - 1) / 2) * (segmentWidth + spacingX);
        segMesh.position.y = ((row - (segmentRows - 1) / 2) * (segmentHeight + spacingY));
        // Attach a unique romantic message to each segment.
        segMesh.userData.message = getRomanticMessage(row * segmentCols + col);
        chocolateBar.add(segMesh);
        segments.push(segMesh);
      }
    }

    /**********************************
     * Chocolate Wrapper (Mesh)       *
     **********************************/
    // The wrapper covers the entire chocolate bar.
    const wrapperWidth = 4.2, wrapperHeight = 2.2;
    const wrapperGeom = new THREE.PlaneGeometry(wrapperWidth, wrapperHeight);
    const wrapperMesh = new THREE.Mesh(wrapperGeom, wrapperMaterial);
    // Position the wrapper just above the chocolate bar.
    wrapperMesh.position.z = segmentDepth / 2 + 0.02;
    scene.add(wrapperMesh);

    /**********************************
     * Utility: Get Romantic Message   *
     **********************************/
    function getRomanticMessage(index) {
      const messages = [
        "You're sweeter than chocolate!",
        "Every moment with you melts my heart.",
        "Your love is as rich as the finest cocoa.",
        "Life is sweeter with you by my side.",
        "A bite of love, a taste of joy.",
        "You make my world a delicious place."
      ];
      return messages[index % messages.length];
    }

    /**********************************
     * GSAP: Wrapper Peel Animation   *
     **********************************/
    function openWrapper() {
      if (isWrapperOpened) return;
      isWrapperOpened = true;
      // Animate the wrapper to rotate and slide to the right,
      // simulating a realistic peel from left to right.
      gsap.to(wrapperMesh.rotation, {
        y: -Math.PI / 2,
        duration: 1.5,
        ease: "power2.inOut"
      });
      gsap.to(wrapperMesh.position, {
        x: 3,
        duration: 1.5,
        ease: "power2.inOut",
        onComplete: createWrapperParticles
      });
    }

    // Create foil particles to simulate crumpling during the peel.
    function createWrapperParticles() {
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement("div");
        particle.className = "wrapper-particle";
        document.body.appendChild(particle);
        gsap.fromTo(particle, {
          x: window.innerWidth / 2,
          y: window.innerHeight / 2,
          scale: 1,
          opacity: 1
        }, {
          duration: 1.5,
          x: window.innerWidth / 2 + (Math.random() - 0.5) * 300,
          y: window.innerHeight / 2 + (Math.random() - 0.5) * 300,
          scale: 0,
          opacity: 0,
          ease: "power2.out",
          onComplete: () => particle.remove()
        });
      }
    }

    /******************************************
     * Particle Effects: Chocolate Crumbs     *
     ******************************************/
    function createCrumbParticles(worldPos) {
      // Convert 3D position to 2D screen coordinates.
      const vector = worldPos.clone().project(camera);
      const x = (vector.x + 1) / 2 * window.innerWidth;
      const y = (-vector.y + 1) / 2 * window.innerHeight;
      for (let i = 0; i < 15; i++) {
        const particle = document.createElement("div");
        particle.className = "particle";
        document.body.appendChild(particle);
        gsap.fromTo(particle, {
          x: x,
          y: y,
          scale: 1,
          opacity: 1
        }, {
          duration: 1.5,
          x: x + (Math.random() - 0.5) * 200,
          y: y + (Math.random() - 0.5) * 200,
          scale: 0,
          opacity: 0,
          ease: "power2.out",
          onComplete: () => particle.remove()
        });
      }
    }

    /******************************************
     * Display Romantic Message               *
     ******************************************/
    function showMessage(text) {
      const msgEl = document.querySelector(".message");
      msgEl.textContent = text;
      gsap.fromTo(msgEl, {
        opacity: 0,
        y: 20
      }, {
        opacity: 1,
        y: 0,
        duration: 0.5,
        ease: "power2.out",
        onComplete: () => {
          gsap.to(msgEl, {
            opacity: 0,
            delay: 3,
            duration: 0.5
          });
        }
      });
    }

    /******************************************
     * Bite Animation: Split & Remove Segment *
     ******************************************/
    function biteChocolate(piece) {
      // If another piece has already been bitten, remove it immediately.
      if (currentBiteGroup && currentBiteGroup !== piece) {
        chocolateBar.remove(currentBiteGroup);
        currentBiteGroup = null;
        if (biteTimeout) { clearTimeout(biteTimeout); biteTimeout = null; }
      }
      // Get the world position for the crumb effect.
      const worldPos = new THREE.Vector3();
      piece.getWorldPosition(worldPos);
      
      // Remove the original piece from the chocolate bar.
      chocolateBar.remove(piece);
      
      // Create two halves representing the bitten piece.
      const bbox = new THREE.Box3().setFromObject(piece);
      const size = new THREE.Vector3();
      bbox.getSize(size);
      const halfWidth = size.x / 2;
      const geometryLeft = new THREE.BoxGeometry(halfWidth, size.y, size.z);
      const geometryRight = new THREE.BoxGeometry(halfWidth, size.y, size.z);
      
      const leftHalf = new THREE.Mesh(geometryLeft, piece.material);
      const rightHalf = new THREE.Mesh(geometryRight, piece.material);
      // Position halves relative to the original piece.
      leftHalf.position.x = piece.position.x - halfWidth / 2;
      rightHalf.position.x = piece.position.x + halfWidth / 2;
      leftHalf.position.y = piece.position.y;
      rightHalf.position.y = piece.position.y;
      leftHalf.position.z = piece.position.z;
      rightHalf.position.z = piece.position.z;
      
      // Group the halves together.
      const biteGroup = new THREE.Group();
      biteGroup.add(leftHalf);
      biteGroup.add(rightHalf);
      chocolateBar.add(biteGroup);
      currentBiteGroup = biteGroup;
      
      // Animate the halves moving apart and then scaling down (bite effect).
      gsap.to(leftHalf.position, {
        x: leftHalf.position.x - 0.5,
        duration: 1,
        ease: "power2.out"
      });
      gsap.to(rightHalf.position, {
        x: rightHalf.position.x + 0.5,
        duration: 1,
        ease: "power2.out"
      });
      gsap.to(biteGroup.scale, {
        x: 0,
        y: 0,
        duration: 1,
        delay: 1,
        ease: "power2.in",
        onComplete: () => {
          chocolateBar.remove(biteGroup);
        }
      });
      
      // Emit chocolate crumb particles.
      createCrumbParticles(worldPos);
      
      // Display the romantic message attached to the piece.
      showMessage(piece.userData.message);
      
      // Remove this bitten piece after 10 seconds if not already removed.
      if (biteTimeout) clearTimeout(biteTimeout);
      biteTimeout = setTimeout(() => {
        if (currentBiteGroup) {
          chocolateBar.remove(currentBiteGroup);
          currentBiteGroup = null;
        }
      }, 10000);
    }

    /******************************************
     * Floating Heart Animation               *
     ******************************************/
    function createFloatingHeart() {
      const heart = document.createElement("div");
      heart.className = "heart";
      heart.style.left = (window.innerWidth / 2 - 15) + "px";
      heart.style.top = (window.innerHeight / 2 - 15) + "px";
      document.body.appendChild(heart);
      // Heart gently pulsates and moves upward repeatedly.
      gsap.to(heart, {
        y: -150,
        scale: 1.2,
        duration: 3,
        ease: "power1.inOut",
        repeat: -1,
        yoyo: true
      });
      // Create a particle trail for the heart.
      function heartTrail() {
        const particle = document.createElement("div");
        particle.className = "particle";
        document.body.appendChild(particle);
        gsap.fromTo(particle, {
          x: parseFloat(heart.style.left),
          y: parseFloat(heart.style.top),
          opacity: 1,
          scale: 1
        }, {
          duration: 1.5,
          x: parseFloat(heart.style.left) + (Math.random() - 0.5) * 100,
          y: parseFloat(heart.style.top) + (Math.random() - 0.5) * 100,
          opacity: 0,
          scale: 0,
          ease: "power2.out",
          onComplete: () => particle.remove()
        });
      }
      setInterval(heartTrail, 500);
    }
    // Create the floating heart as soon as the page loads.
    createFloatingHeart();

    /******************************************
     * Interaction: Raycaster & Mouse Click     *
     ******************************************/
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onClick(event) {
      // Convert the mouse coordinates to normalized device coordinates.
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (!isWrapperOpened) {
        // If the wrapper is still intact, check for a click on it.
        const intersects = raycaster.intersectObject(wrapperMesh);
        if (intersects.length > 0) {
          openWrapper();
        }
      } else {
        // Once unwrapped, check for clicks on any chocolate segment.
        const intersects = raycaster.intersectObjects(segments, true);
        if (intersects.length > 0) {
          const clickedPiece = intersects[0].object;
          biteChocolate(clickedPiece);
        }
      }
    }
    window.addEventListener("click", onClick);

    /******************************************
     * Render Loop & Resize Handling          *
     ******************************************/
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
